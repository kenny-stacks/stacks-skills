---
phase: 04-tdd-workflow-contract-implementation
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - skills/stacks-dev/references/clarity-implementation.md
autonomous: true

must_haves:
  truths:
    - "Developer can apply Clarity coding style patterns (sequential asserts, meaningful errors) using documented examples"
    - "Developer can apply storage optimization patterns (hash storage, minimize on-chain) using documented examples"
    - "Developer can apply upgradability patterns (modular architecture, dynamic principals) using documented examples"
    - "Reference file documents which violations are auto-fixable vs require user confirmation (SKILL.md Phase 3 implements auto-fix)"
  artifacts:
    - path: "skills/stacks-dev/references/clarity-implementation.md"
      provides: "Clarity best practices reference for Phase 3"
      contains: "Coding Style Patterns"
      min_lines: 150
  key_links:
    - from: "clarity-implementation.md"
      to: "Clarity Book Chapter 13"
      via: "external links"
      pattern: "book.clarity-lang.org/ch13"
---

<objective>
Create new clarity-implementation.md reference file with Clarity best practices for coding style, storage, and upgradability.

Purpose: Provide comprehensive guidance for the Implementation phase (Phase 3) including patterns from Clarity Book Chapter 13 that can be auto-checked and auto-fixed.

Output: New clarity-implementation.md (~150-180 lines) with:
- Coding style patterns (CONT-02)
- Storage optimization patterns (CONT-03)
- Upgradability patterns (CONT-04)
- Auto-fix guidance for mechanical violations
</objective>

<execution_context>
@/Users/kenny/.claude/get-shit-done/workflows/execute-plan.md
@/Users/kenny/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

# Phase context with decisions about auto-fix behavior
@.planning/phases/04-tdd-workflow-contract-implementation/04-CONTEXT.md
@.planning/phases/04-tdd-workflow-contract-implementation/04-RESEARCH.md

# Existing design reference (to avoid duplication - already has modular architecture)
@skills/stacks-dev/references/clarity-design.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create clarity-implementation.md with best practices patterns</name>
  <files>skills/stacks-dev/references/clarity-implementation.md</files>
  <action>
Create new reference file clarity-implementation.md with the following sections (keep under 180 lines):

## Coding Style Patterns (CONT-02)

### Sequential Asserts Pattern
From RESEARCH.md - show BAD (nested if) vs GOOD (sequential asserts):
```clarity
;; BAD: Nested if statements
(define-public (transfer (amount uint) (recipient principal))
  (if (> amount u0)
    (if (<= amount (get-balance tx-sender))
      (ok (do-transfer amount recipient))
      (err u100))
    (err u101)))

;; GOOD: Sequential asserts
(define-public (transfer (amount uint) (recipient principal))
  (begin
    (asserts! (> amount u0) (err u101))           ;; ERR-ZERO-AMOUNT
    (asserts! (<= amount (get-balance tx-sender)) (err u100)) ;; ERR-INSUFFICIENT-BALANCE
    (ok (do-transfer amount recipient))))
```

### Explicit Error Handling
- Use `unwrap!` with error codes, NOT `unwrap-panic`
- Use `try!` to propagate errors
- Define meaningful error constants: `(define-constant ERR-NOT-AUTHORIZED (err u401))`

### Unnecessary Begin Removal
- `begin` only needed for multiple sequential expressions
- Single expression doesn't need wrapping
- Auto-fixable: remove begin around single expressions

### Error Code Conventions
- Use HTTP-like error codes (400=bad request, 401=unauthorized, 404=not found)
- Define constants at top of contract
- Comment error codes inline: `(err u401) ;; ERR-NOT-AUTHORIZED`

## Storage Patterns (CONT-03)

### Hash Storage for Large Data
- Store hash on-chain, data off-chain
- Use `(hash160 data)` for content addressing
- Pattern: `(define-map data-hashes principal (buff 20))`

### Minimize On-Chain Storage
- Store only what's needed for on-chain logic
- Use maps efficiently (no redundant data)
- Consider `at-block` for historical queries

### Data Separation
- Separate data contracts from logic contracts
- Data contract: defines maps and read/write functions
- Logic contract: defines business rules, calls data contract

## Upgradability Patterns (CONT-04)

Note: Detailed ExecutorDAO pattern is in clarity-design.md. This section covers implementation-level patterns.

### Dynamic Principals
- Use `define-data-var authorized-contract principal` for upgradable references
- Allow admin to update contract references
- Pattern for contract-call through variable principal

### Function Dispatch
- Use trait-based dispatch for upgradable logic
- Define traits for contract interfaces
- Implement dispatch contracts that delegate to implementations

## Auto-Fix Guidance

This section documents patterns for SKILL.md Phase 3 to implement auto-fix behavior.
The reference file provides the rules; SKILL.md Phase 3 applies them during implementation.

### Auto-Fixable (SKILL.md applies without asking):
- Remove unnecessary `begin` blocks
- Replace `unwrap-panic` with `unwrap!` + error code
- Add missing error constant definitions
- Format error codes consistently

### Ask Before Fixing (SKILL.md prompts user first):
- Restructuring nested if â†’ sequential asserts (may change execution order)
- Moving data to separate contract (architectural change)
- Adding upgrade mechanisms (security implications)

## Review Workflow

From CONTEXT.md decisions:
1. Review after each function implementation
2. Auto-fix violations, explain what was changed and WHY
3. Educational feedback: link to Clarity Book section
4. Run `clarinet check` after every modification

## External References

- [Clarity Book Ch13-01: Coding Style](https://book.clarity-lang.org/ch13-01-coding-style.html)
- [Clarity Book Ch13-02: Storage Optimization](https://book.clarity-lang.org/ch13-02-what-to-store-on-chain.html)
- [Clarity Book Ch13-03: Upgradability](https://book.clarity-lang.org/ch13-03-contract-upgradability.html)
- [Clarity Language Reference](https://docs.stacks.co/clarity/language-overview)
  </action>
  <verify>
File exists and contains expected sections:
```bash
ls skills/stacks-dev/references/clarity-implementation.md
wc -l skills/stacks-dev/references/clarity-implementation.md
grep -c "Sequential Asserts" skills/stacks-dev/references/clarity-implementation.md
grep -c "Storage" skills/stacks-dev/references/clarity-implementation.md
grep -c "Upgradability" skills/stacks-dev/references/clarity-implementation.md
grep -c "Auto-Fix" skills/stacks-dev/references/clarity-implementation.md
```
  </verify>
  <done>
clarity-implementation.md exists with coding style, storage, upgradability patterns, and auto-fix guidance - ready to support SKILL.md Phase 3.
  </done>
</task>

</tasks>

<verification>
After task completion, verify:
1. File exists: `ls skills/stacks-dev/references/clarity-implementation.md`
2. Line count: `wc -l skills/stacks-dev/references/clarity-implementation.md` (target: 150-180 lines)
3. Contains key patterns: Sequential Asserts, Storage, Upgradability, Auto-Fix
4. Links to Clarity Book Chapter 13 sections
5. Clear distinction between auto-fixable and ask-before-fixing changes
</verification>

<success_criteria>
1. clarity-implementation.md contains Coding Style Patterns section with sequential asserts
2. clarity-implementation.md contains Storage Patterns section with hash storage, minimize on-chain
3. clarity-implementation.md contains Upgradability Patterns section (implementation-level, not design)
4. clarity-implementation.md contains Auto-Fix Guidance distinguishing mechanical vs structural changes
5. clarity-implementation.md links to Clarity Book Ch13 sections (coding style, storage, upgradability)
6. File is under 180 lines (progressive disclosure)
7. No duplication with clarity-design.md (which has ExecutorDAO pattern)
</success_criteria>

<output>
After completion, create `.planning/phases/04-tdd-workflow-contract-implementation/04-02-SUMMARY.md`
</output>
